// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Dial.h"
#include "thrift/protocol/TBinaryProtocol.h"
#include "thrift/protocol/TProtocol.h"
#include "thrift/server/TSimpleServer.h"
#include "thrift/transport/TServerSocket.h"
#include "thrift/transport/TBufferTransports.h"
#include "thrift/transport/TSocket.h"
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include<sys/time.h>
#include<vector>
#include <arpa/nameser.h>
#include <resolv.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/resource.h>
#include <signal.h>


#include "Agent.h"
#include "Dial_server.h"
#include "Dial_hash.h"
#include "Dial_mode.h"
#include "Dial_thread_pool.h"
#include "Dial_queue.h"
#include "Dial_icmp.h"
#include "Dial_common.h"
#include "Dial_dns.h"
#include "Dial_ssl.h"
#include "version.h"
#include <clib/daemon.h>


using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

#define	HASH_POLICY_NUM	100
#define	HASH_NGINX_NUM	500
#define	HASH_GROUP_NUM	1000
#define	THREAD_POOL_NUM	20
#define HTTPGET_PORT 	80
#define	CONFIG_FILE		"/etc/dial_config"

hash_info_t 		hs_health_policy;
hash_info_t 		hs_health_group;
hash_info_t 		hs_nginx_group;
DIAL_LIST_HEAD 		list_dial_srv;
queue_info_t		queue_info;
threadpool_t 		tp;
int					raw_fd;
int 				primary_flag;	
pthread_mutex_t		client_lock;
bool				client_connecting_flag = false;
bool				registered_flag = false;
dial_cfg_t 			g_cfg;
bool 				s_debug_switch;
pthread_mutex_t 	g_log_lock;
bool 				thread_exit_flag;

//using namespace  ::rpc::yamutech::com;


//boost::shared_ptr<TSocket> tsocket(new TSocket("192.168.6.58", MS_PORT));  
boost::shared_ptr<TTransport> transport_client;  
boost::shared_ptr<TProtocol> protocol_client; 


healthpolicy_info_t *
find_healthpolicy_node_by_name(char *policyname)
{
	DIAL_LIST_NODE *cur = NULL;
	healthpolicy_info_t *hp_node = NULL;
	RetCode::type ret;
	
	cur = hs_health_policy.hash_search(&hs_health_policy,policyname);
	hp_node = (healthpolicy_info_t *)cur;
	
	return hp_node;
}


healthgroup_info_t *
find_healthgroup_node(healthgroup_info_t *search_node,hash_info_t *hs)
{
	healthgroup_info_t *hg = NULL;
	DIAL_LIST_NODE *cur = NULL;
	DIAL_LIST_NODE *head = NULL;
	DIAL_LIST_HEAD *head_node = NULL;	
	int key;
	
	key = hs->hash_key((void *)search_node,hs->num);

	head = &hs->tab[key].head;
	head_node = &hs->tab[key];
	
	pthread_mutex_lock(&head_node->lock);
	
	list_for_each(cur, head) {
		hg = (healthgroup_info_t *)cur;
		if(!strcmp(hg->viewname,search_node->viewname) && !strcmp(hg->zonename,search_node->zonename) && !strcmp(hg->name,search_node->name)) {
			break;
		}
	}
	
	pthread_mutex_unlock(&head_node->lock);

	if(cur != head)
		return hg;
	else
		return NULL;
}

nginxgroup_info_t *
find_nginxgroup_node(nginxgroup_info_t *search_node,hash_info_t *hs)
{
  nginxgroup_info_t *ng = NULL;
  DIAL_LIST_NODE *cur = NULL;
  DIAL_LIST_NODE *head = NULL;
  DIAL_LIST_HEAD *head_node = NULL;   
  int key;

  
  
  key = hs->hash_key((void *)search_node->name,hs->num);
  
  head = &hs->tab[key].head;
  head_node = &hs->tab[key];
  
  pthread_mutex_lock(&head_node->lock);
  
  list_for_each(cur, head) {
	  ng = (nginxgroup_info_t *)cur;
	  if(!strcmp(ng->name,search_node->name)) {
		  break;
	  }
  }

  
  pthread_mutex_unlock(&head_node->lock);

  if(cur != head)
	  return ng;
  else
	  return NULL;
}



  RetCode::type DialHandler::systemCommand(const SysCommand::type cmdType) {

	
	return RetCode::OK; 
  }

/*
  RetCode::type DialHandler::isPrimary(const bool isPrimary) {

	primary_flag = isPrimary;
	cfg_debug_printf(LOG_LEVEL_BASIC,"isPrimary:isPrimary = %d\n",isPrimary);
	
	return RetCode::OK;
  }


void DialHandler::heartBeat(HeartBeatState& _return) {

	cfg_debug_printf(LOG_LEVEL_BASIC,"heartBeat:receive a heat beat!!\n");

	if(registered_flag)
		_return.__set_mState(ModuleState::REGISTERED);
	else
		_return.__set_mState(ModuleState::STARTUP);
  }
*/ 

  void DialHandler::heartBeat(HeartBeatState& _return) {
    // Your implementation goes here
    //printf("heartBeat\n");
	
	static int index_sec = 0;

	if(index_sec % 60 == 0)
	{
		cfg_debug_printf(LOG_LEVEL_BASIC,"heartBeat:receive a heat beat!!\n");
		index_sec = 0;
	}
	index_sec++;	

	if(registered_flag)
	{
		_return.__set_mState(ModuleState::REGISTERED);
		_return.__set_serverState(false);
	}	
	else
	{
		_return.__set_mState(ModuleState::STARTUP);
		_return.__set_serverState(true);
	}	
  }

  RetCode::type DialHandler::setServerState(const bool enable) {
    // Your implementation goes here
    //printf("setServerState\n");
	
	primary_flag = enable;
	cfg_debug_printf(LOG_LEVEL_BASIC,"isPrimary:enable = %d\n",primary_flag);
	
	return RetCode::OK;
  }


RetCode::type DialHandler:: addHealthGroup(const HealthGroupInfo& health, const std::string& policyName) {

	DIAL_LIST_NODE *cur = NULL;
	DIAL_LIST_NODE *head = NULL;
	DIAL_LIST_HEAD *head_node = NULL;
	healthgroup_info_t *hg = NULL;
	healthgroup_info_t *hg_node = NULL;
	healthgroup_info_t hg_tmp;
	pPolicy_node_t *pPolicy_node = NULL;
	healthpolicy_info_t *policy = NULL;
	int key;

	cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:start!!!name = %s,policyName=%s\n",health.name.c_str(),policyName.c_str());	

	policy = find_healthpolicy_node_by_name((char *)policyName.c_str());
	if(NULL == policy) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:find_healthpolicy_node_by_name failed,no policy node<%s>!!!\n",policyName.c_str());
		return RetCode::FAIL;
	}
	
	pPolicy_node = (pPolicy_node_t *)malloc(sizeof(pPolicy_node_t));
	if(NULL == pPolicy_node) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:malloc pPolicy_node failed!!!\n");
		return RetCode::FAIL;
	}
	memset(pPolicy_node,0,sizeof(pPolicy_node_t));
	
	pPolicy_node->pPolicy = policy;
	gettimeofday(&pPolicy_node->t_insert,NULL);
	pPolicy_node->t_insert.tv_sec += pPolicy_node->pPolicy->freq;

	memset(&hg_tmp,0,sizeof(healthgroup_info_t));
	strcpy(hg_tmp.viewname,health.viewName.c_str());
	strcpy(hg_tmp.zonename,health.zoneName.c_str());
	strcpy(hg_tmp.name,health.name.c_str());

	key = hs_health_group.hash_key((void *)&hg_tmp,hs_health_group.num);
	head = &hs_health_group.tab[key].head;
	head_node = &hs_health_group.tab[key];

	pthread_mutex_lock(&head_node->lock);
	
	list_for_each(cur, head) {
		hg = (healthgroup_info_t *)cur;
		if(!strcmp(hg->viewname,hg_tmp.viewname) && !strcmp(hg->zonename,hg_tmp.zonename) && !strcmp(hg->name,hg_tmp.name)) {
			break;
		}
	}
	pthread_mutex_unlock(&head_node->lock);

	if(cur != head) {
		list_add(&hg->pPolicy_head,&pPolicy_node->node);
		cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:attach a policy=%s to group=%s!!!\n",policyName.c_str(),health.name.c_str());		
	} else {
		cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:add a new group=%s,policy=%s\n",health.name.c_str(),policyName.c_str());
		hg_node = (healthgroup_info_t *)malloc(sizeof(healthgroup_info_t));
		if(NULL == hg_node) {
			cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:malloc hg_node failed!!!\n");
			free(pPolicy_node);
			return RetCode::FAIL;
		}
		memset(hg_node,0,sizeof(healthgroup_info_t));

		strcpy(hg_node->viewname,health.viewName.c_str());
		strcpy(hg_node->zonename,health.zoneName.c_str());
		strcpy(hg_node->name,health.name.c_str());
		list_head_init(&hg_node->record_head);
		list_head_init(&hg_node->pPolicy_head);

		list_add(&hg_node->pPolicy_head,&pPolicy_node->node);
		hs_health_group.hash_add(&hs_health_group,hg_node,&hg_node->node);
	}
		
	cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:success!!!name = %s,policyName=%s\n",health.name.c_str(),policyName.c_str());	
	//debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:success!!!\n");
	return RetCode::OK;
}

/*RetCode::type DialHandler:: modHealthGroup(const HealthGroupInfo& health, const std::string& policyName) {
	cfg_debug_printf(LOG_LEVEL_BASIC,"modHealthGroup:start!!!name = %s,policyName=%s\n",health.name.c_str(),policyName.c_str());

	healthgroup_info_t hg_node;
	int key;
	DIAL_LIST_NODE *cur = NULL;
	DIAL_LIST_NODE *head = NULL;
	DIAL_LIST_HEAD *head_node = NULL;
	healthgroup_info_t *hg = NULL;
	RetCode::type ret = RetCode::OK;
	
	memset(&hg_node,0,sizeof(healthgroup_info_t));

	 strcpy(hg_node.viewname,health.viewName.c_str());
	 strcpy(hg_node.zonename,health.zoneName.c_str());
	 strcpy(hg_node.name,health.name.c_str());
	
	hg_node.pPolicy = find_healthpolicy_node_by_name((char *)policyName.c_str());
	if(NULL == hg_node.pPolicy) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"modHealthGroup:find_healthpolicy_node_by_name failed,no policy node<%s>!!!\n",policyName.c_str());
		//free(hg_node);
		return RetCode::FAIL;
	}

	key = hs_health_group.hash_key((void *)&hg_node,hs_health_group.num);

	head = &hs_health_group.tab[key].head;
	head_node = &hs_health_group.tab[key];
	
	pthread_mutex_lock(&head_node->lock);
	
	list_for_each(cur, head) {
		hg = (healthgroup_info_t *)cur;
		if(!strcmp(hg->viewname,hg_node.viewname) && !strcmp(hg->zonename,hg_node.zonename) && !strcmp(hg->name,hg_node.name)) {
			break;
		}
	}

	if(cur != head) {
		hg->pPolicy = hg_node.pPolicy;
		//debug_printf(LOG_LEVEL_BASIC,"modHealthGroup:success!!!\n");		
	} else {
		cfg_debug_printf(LOG_LEVEL_BASIC,"modHealthGroup:can not find the target node!!!viewname=%s,zonename=%s,name=%s\n",
		hg_node.viewname,hg_node.zonename,hg_node.name);
		ret = RetCode::FAIL;
	}
	
	pthread_mutex_unlock(&head_node->lock);

	return ret;
}*/

RetCode::type DialHandler:: delHealthGroup(const HealthGroupInfo& health, const std::string& policyName) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthGroup:start!!!,viewname=%s,zonename=%s,name=%s,policyName=%s\n",health.viewName.c_str(),health.zoneName.c_str(),health.name.c_str(),policyName.c_str());
	healthgroup_info_t hg_node;
	int key;
	DIAL_LIST_NODE *cur = NULL;
	DIAL_LIST_NODE *head = NULL;
	DIAL_LIST_NODE *node = NULL;
	DIAL_LIST_HEAD *head_node = NULL;
	healthgroup_info_t *hg = NULL;
	pPolicy_node_t *pPolicy_node = NULL;
	RetCode::type ret = RetCode::OK;
	
	memset(&hg_node,0,sizeof(healthgroup_info_t));

	 strcpy(hg_node.viewname,health.viewName.c_str());
	 strcpy(hg_node.zonename,health.zoneName.c_str());
	 strcpy(hg_node.name,health.name.c_str());
	

	key = hs_health_group.hash_key((void *)&hg_node,hs_health_group.num);
	node = hs_health_group.hash_search(&hs_health_group,(char *)&hg_node);
	if(NULL == node) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthGroup:failed,can not find health group node!!!\n");
		return RetCode::FAIL;
	}

	head_node = &hs_health_group.tab[key];
	hg = (healthgroup_info_t *)node;
	head = &hg->pPolicy_head.head;
	
	pthread_mutex_lock(&hg->pPolicy_head.lock);
	
	list_for_each(cur,head) {
		pPolicy_node = (pPolicy_node_t *)cur;
		if(!strcmp(pPolicy_node->pPolicy->policyname,policyName.c_str()))
			break;
	}
	
	pthread_mutex_unlock(&hg->pPolicy_head.lock);
	
	if(cur != head) {
		list_del(&hg->pPolicy_head,&pPolicy_node->node);
		free(pPolicy_node);
		if(hg->pPolicy_head.num < 1){
			list_del(head_node,&hg->node);
			free(hg);
		}
	}else{
		cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthGroup:can not find target policynode=%s from group=%s!!!\n",policyName.c_str(),health.name.c_str());
	}
	
	cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthGroup:success!!!,viewname=%s,zonename=%s,name=%s,policyName=%s\n",health.viewName.c_str(),health.zoneName.c_str(),health.name.c_str(),policyName.c_str());
	//cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthGroup:success!!!\n");
	return ret;
}

RetCode::type DialHandler:: addHealthRecord(const HealthGroupInfo& health, const DialRecord& rec) {
		//cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthRecord:start!!!\n");

	healthgroup_info_t hg_node;
	DIAL_LIST_NODE *cur = NULL;
	DIAL_LIST_NODE *head = NULL;
	DIAL_LIST_HEAD *head_node = NULL;
	healthgroup_info_t *hg = NULL;
	
	record_info_t *r_node = (record_info_t *)malloc(sizeof(record_info_t));
	if(NULL == r_node) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthRecord:malloc failed!!!\n");
		return RetCode::FAIL;
	}

	memset(r_node,0,sizeof(record_info_t));

	strcpy(r_node->rid,rec.rid.c_str());
	r_node->ip.version = rec.ip.version;
	strcpy(r_node->ip.addr,rec.ip.addr.c_str());
	r_node->priority = rec.priority;
	r_node->ttl= rec.ttl;
	r_node->enabled = rec.enabled;

	//cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthRecord:view=%s,zone=%s,dn=%s,ip=%s,version=%d,priority=%d,ttl=%d,enabaled=%d\n",health.viewName.c_str(),health.zoneName.c_str(),health.name.c_str(),rec.ip.addr.c_str(),rec.ip.version,rec.priority,rec.ttl,rec.enabled);
	
	memset(&hg_node,0,sizeof(healthgroup_info_t));
	 strcpy(hg_node.viewname,health.viewName.c_str());
	 strcpy(hg_node.zonename,health.zoneName.c_str());
	 strcpy(hg_node.name,health.name.c_str());

	cur = hs_health_group.hash_search(&hs_health_group,(char *)&hg_node);
	if(NULL == cur) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthRecord:failed,can not find health group node!!!,dn=%s,view=%s,zone=%s,ip=%s\n",health.name.c_str(),health.viewName.c_str(),health.zoneName.c_str(),rec.ip.addr.c_str());
		free(r_node);
		return RetCode::FAIL;
	}

	
	hg = (healthgroup_info_t *)cur;
	
	 head_node = &hg->record_head;

	list_add(head_node,&r_node->node);

	cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthRecord success!!!: view=%s,zone=%s,dn=%s,ip=%s,version=%d,priority=%d,ttl=%d,enabaled=%d\n",health.viewName.c_str(),health.zoneName.c_str(),health.name.c_str(),rec.ip.addr.c_str(),rec.ip.version,rec.priority,rec.ttl,rec.enabled);
	//cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthRecord:success!!!\n");
	return RetCode::OK;
}

RetCode::type DialHandler:: modHealthRecord(const HealthGroupInfo& health, const DialRecord& rec) {
		//cfg_debug_printf(LOG_LEVEL_BASIC,"modHealthRecord:start!!!\n");
	healthgroup_info_t hg_node;
	DIAL_LIST_NODE *cur = NULL;
	DIAL_LIST_NODE *head = NULL;
	DIAL_LIST_HEAD *head_node = NULL;
	healthgroup_info_t *hg = NULL;
	record_info_t *prec = NULL;
	RetCode::type ret = RetCode::OK;
	
	
	memset(&hg_node,0,sizeof(healthgroup_info_t));
	 strcpy(hg_node.viewname,health.viewName.c_str());
	 strcpy(hg_node.zonename,health.zoneName.c_str());
	 strcpy(hg_node.name,health.name.c_str());

	cfg_debug_printf(LOG_LEVEL_BASIC,"modHealthRecord:dn=%s,ip=%s,version=%d,priority=%d,ttl=%d,enabaled=%d\n",health.name.c_str(),rec.ip.addr.c_str(),rec.ip.version,rec.priority,rec.ttl,rec.enabled);


	cur = hs_health_group.hash_search(&hs_health_group,(char *)&hg_node);
	if(NULL == cur) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"modHealthRecord:failed,can not find health group node!!!\n");
		return RetCode::FAIL;
	}

	hg = (healthgroup_info_t *)cur;
	
	 head_node = &hg->record_head;
	 head = &head_node->head;

	pthread_mutex_lock(&head_node->lock);
	
	 list_for_each(cur, head) {
		prec = (record_info_t *)cur;
		if(!strcmp(prec->rid,rec.rid.c_str()))
			break;
	 }
	if(cur != head) {
		strcpy(prec->rid,rec.rid.c_str());
		prec->ip.version = rec.ip.version;
		strcpy(prec->ip.addr,rec.ip.addr.c_str());
		prec->priority = rec.priority;
		prec->ttl= rec.ttl;
		prec->enabled = rec.enabled;
		//cfg_debug_printf(LOG_LEVEL_BASIC,"modHealthRecord:success!!!\n");
	} else {
		cfg_debug_printf(LOG_LEVEL_BASIC,"modHealthRecord:failed,can not find target node.viewname=%s,zonename=%s,name=%s!!!\n",hg_node.viewname,
			hg_node.zonename,hg_node.name);
		ret = RetCode::FAIL;
	}
	 
	 pthread_mutex_unlock(&head_node->lock);
	 
	return ret;
}

RetCode::type DialHandler:: delHealthRecord(const HealthGroupInfo& health, const DialRecord& rec) {
		//cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthRecord:start!!!\n");
	healthgroup_info_t hg_node;
	DIAL_LIST_NODE *cur = NULL;
	DIAL_LIST_NODE *head = NULL;
	DIAL_LIST_HEAD *head_node = NULL;
	healthgroup_info_t *hg = NULL;
	record_info_t *prec = NULL;
	RetCode::type ret = RetCode::OK;
	
	
	memset(&hg_node,0,sizeof(healthgroup_info_t));
	 strcpy(hg_node.viewname,health.viewName.c_str());
	 strcpy(hg_node.zonename,health.zoneName.c_str());
	 strcpy(hg_node.name,health.name.c_str());

	cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthRecord:dn=%s,ip=%s,version=%d,priority=%d,ttl=%d,enabaled=%d\n",health.name.c_str(),rec.ip.addr.c_str(),rec.ip.version,rec.priority,rec.ttl,rec.enabled);

	cur = hs_health_group.hash_search(&hs_health_group,(char *)&hg_node);
	if(NULL == cur) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthRecord:failed,can not find health group node!!!\n");
		return RetCode::FAIL;
	}

	hg = (healthgroup_info_t *)cur;
	
	 head_node = &hg->record_head;
 	head = &head_node->head;
	
	pthread_mutex_lock(&head_node->lock);
	
	 list_for_each(cur, head) {
		prec = (record_info_t *)cur;
		if(!strcmp(prec->rid,rec.rid.c_str()))
			break;
	 }
	if(cur != head) {

		cur->next->prev = cur->prev;
		cur->prev->next = cur->next;
		head_node->num--;
		free(prec);
		cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthRecord:success!!!dn=%s,ip=%s\n",health.name.c_str(),rec.ip.addr.c_str());
	} else {
		cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthRecord:failed,can not find target node.viewname=%s,zonename=%s,name=%s!!!\n",hg_node.viewname,
			hg_node.zonename,hg_node.name);
		ret = RetCode::FAIL;
	}
	 pthread_mutex_unlock(&head_node->lock); 
	 
	return ret;
}

void
init_dial_option(dial_option_t *dialoption,const DialOption &option)
{
	unsigned int i = 0;
	match_code_t *mcode = NULL;

	
	strcpy(dialoption->dest_url,option.destUrl.c_str());	
	strcpy(dialoption->test_method,option.testMethod.c_str());	
	strcpy(dialoption->expect_match,option.expectMatch.c_str());	
	cfg_debug_printf(LOG_LEVEL_BASIC,"init_dial_option:dest_url=%s,test_method=%d,expect_match=%s,matchcode_num=%d\n",dialoption->dest_url,dialoption->test_method,dialoption->expect_match,option.expectCode.size());

	list_head_init(&dialoption->code_head);
	
	for(i= 0;i < option.expectCode.size();i++) {
		mcode = (match_code_t *)calloc(1,sizeof(match_code_t));
		mcode->code = option.expectCode[i];
		list_add(&dialoption->code_head,&mcode->node);	
		cfg_debug_printf(LOG_LEVEL_BASIC,"init_dial_option:match_code=%d\n",mcode->code);
	}

}

void
modify_dial_option(dial_option_t *dialoption, const DialOption &option)
{
	unsigned int i = 0;
	match_code_t *mcode = NULL;
	DIAL_LIST_NODE *cur,*tmp,*head;

	memset(dialoption->dest_url,0,sizeof(dialoption->dest_url));
	memset(dialoption->test_method,0,sizeof(dialoption->test_method));
	memset(dialoption->expect_match,0,sizeof(dialoption->expect_match));
	
	strcpy(dialoption->dest_url,option.destUrl.c_str());	
	strcpy(dialoption->test_method,option.testMethod.c_str());	
	strcpy(dialoption->expect_match,option.expectMatch.c_str());	

	head = &dialoption->code_head.head;

	list_for_each_safe(cur,tmp,head) {
		list_del(&dialoption->code_head,cur);
		mcode = (match_code_t *)cur;
		free(mcode);
	}

	for(i= 0;i < option.expectCode.size();i++) {
		mcode = (match_code_t *)calloc(1,sizeof(match_code_t));
		mcode->code = option.expectCode[i];
		list_add(&dialoption->code_head,&mcode->node);	
	}

}


void
del_dial_option(dial_option_t *dialoption)
{
	int i = 0;
	match_code_t *mcode = NULL;
	DIAL_LIST_NODE *cur,*tmp,*head;


	head = &dialoption->code_head.head;

	list_for_each_safe(cur,tmp,head) {
		list_del(&dialoption->code_head,cur);
		mcode = (match_code_t *)cur;
		free(mcode);
	}
}


RetCode::type DialHandler:: addHealthPolicy(const HealthPolicyInfo& policy) {
	cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthPolicy:start!!!,policyname=%s\n",policy.name.c_str());

	healthpolicy_info_t *hp_node = (healthpolicy_info_t *)malloc(sizeof(healthpolicy_info_t));
	if(NULL == hp_node) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthPolicy:malloc failed!!!\n");
		return RetCode::FAIL;
	}
	
	memset(hp_node,0,sizeof(healthpolicy_info_t));

	strcpy(hp_node->policyname,policy.name.c_str());
	hp_node->method = policy.method;
	hp_node->port = policy.port;
	hp_node->freq = policy.freq;
	hp_node->times = policy.times;
	hp_node->passed = policy.passed;

	init_dial_option(&hp_node->dial_option,policy.option);

	hs_health_policy.hash_add(&hs_health_policy,hp_node->policyname,&hp_node->node);
	
	cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthPolicy:success!!!,policyname=%s\n",policy.name.c_str());
	//cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthPolicy:success!!!\n");
	return RetCode::OK;
}

RetCode::type DialHandler:: modHealthPolicy(const HealthPolicyInfo& policy) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"modHealthPolicy:start!!!,policyname=%s\n",policy.name.c_str());

	DIAL_LIST_NODE *cur = NULL;
	DIAL_LIST_NODE *head = NULL;
	DIAL_LIST_HEAD *head_node = NULL;
	healthpolicy_info_t *hp_node = NULL;
	RetCode::type ret = RetCode::OK;
	int key;
	
	//cur = hs_health_policy.hash_search(&hs_health_policy,policy.name.c_str());
	key = hs_health_policy.hash_key((char *)policy.name.c_str(),hs_health_policy.num);

	head = &hs_health_policy.tab[key].head;
	head_node = &hs_health_policy.tab[key];
	
	pthread_mutex_lock(&head_node->lock);
	
	list_for_each(cur, head) {
		hp_node = (healthpolicy_info_t *)cur;
		if(!strcmp(policy.name.c_str(),hp_node->policyname)) {
			break;
		}
	}

	if(NULL != head) {
		hp_node->method = policy.method;
		hp_node->port = policy.port;
		hp_node->freq = policy.freq;
		hp_node->times = policy.times;
		hp_node->passed = policy.passed;
		modify_dial_option(&hp_node->dial_option,policy.option);
		//cfg_debug_printf(LOG_LEVEL_BASIC,"modHealthPolicy:success!!!\n");		
	} else {
		cfg_debug_printf(LOG_LEVEL_BASIC,"modHealthPolicy:can not find the target node!!!name=%s\n",policy.name.c_str());
		ret = RetCode::FAIL;
	}
	pthread_mutex_unlock(&head_node->lock);

	return ret;
}

RetCode::type DialHandler:: delHealthPolicy(const HealthPolicyInfo& policy) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthPolicy:start!!!,policyname=%s\n",policy.name.c_str());
	DIAL_LIST_NODE *cur = NULL;
	healthpolicy_info_t *hp_node = NULL;
	RetCode::type ret = RetCode::OK;
	int key;
	
	cur = hs_health_policy.hash_search(&hs_health_policy,(char *)policy.name.c_str());
	key = hs_health_policy.hash_key((void *)policy.name.c_str(),hs_health_policy.num);
	
	if(NULL != cur) {
		hp_node = (healthpolicy_info_t *)cur;
		list_del(&hs_health_policy.tab[key],cur);
		del_dial_option(&hp_node->dial_option);
		free(hp_node);
		//cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthPolicy:success!!!\n");
	} else {
		cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthPolicy:can not find the target node!!!name=%s\n",policy.name.c_str());
		ret = RetCode::FAIL;
	}
		
	return ret;

}
  RetCode::type DialHandler::dialServerConfig(const DialServerType::type typ, const bool allowed) {
	cfg_debug_printf(LOG_LEVEL_BASIC,"dialServerConfig:start!!!,type=%d,allowed=%d\n",typ,allowed);

	g_cfg.srv_cfg.allowed[typ] = allowed;
	
	return RetCode::OK;
  }

RetCode::type DialHandler::addDialServer(const IpAddr& ip, const DialServerType::type typ) {
	cfg_debug_printf(LOG_LEVEL_BASIC,"addDialServer:start!!!,ip=%s,type=%d\n",ip.addr.c_str(),typ);

	dial_srv_node_t *srv_node = (dial_srv_node_t *)malloc(sizeof(dial_srv_node_t));
	if(NULL == srv_node) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"addDialServer:malloc failed!!!\n");
		return RetCode::FAIL;
	}
	
	memset(srv_node,0,sizeof(dial_srv_node_t));
	strcpy(srv_node->ip.addr,ip.addr.c_str());
	srv_node->ip.version = ip.version;
	srv_node->srv_tpye = typ;
	gettimeofday(&srv_node->t_insert,NULL);
	srv_node->t_insert.tv_sec += g_cfg.srv_cfg.interval;
	
	
	list_add(&list_dial_srv,&srv_node->node);
	

	return RetCode::OK;
  }

 RetCode::type DialHandler::delDialServer(const IpAddr& ip, const DialServerType::type typ) {
 	cfg_debug_printf(LOG_LEVEL_BASIC,"delDialServer:start!!!,ip=%s,type=%d\n",ip.addr.c_str(),typ);

	DIAL_LIST_NODE *cur = NULL;
	DIAL_LIST_NODE *tmp = NULL;
	DIAL_LIST_NODE *head = &list_dial_srv.head;
	dial_srv_node_t *srv_node  =NULL;

	list_for_each_safe(cur, tmp, head) {
		srv_node = (dial_srv_node_t *)cur;
		
		if(!strcmp(ip.addr.c_str(),srv_node->ip.addr) && typ == srv_node->srv_tpye)
			break;

	}
	if(cur == head) {
		return RetCode::FAIL;
		cfg_debug_printf(LOG_LEVEL_BASIC,"delDialServer:ip=%s,type=%d failed!!!\n",ip.addr.c_str(),typ);
	}else
		list_del(&list_dial_srv,cur);
	
	return RetCode::OK;
}

RetCode::type DialHandler::addNginxGroup(const std::string& groupName, const std::string& policyName) 
{
	cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:start!!!groupName = %s,policyName=%s\n",groupName.c_str(),policyName.c_str());
	DIAL_LIST_NODE *cur = NULL;
	DIAL_LIST_NODE *head = NULL;
	DIAL_LIST_HEAD *head_node = NULL;
	nginxgroup_info_t *ng = NULL;
	nginxgroup_info_t ng_node;
	nginxgroup_info_t *nginx_node = NULL;
	pPolicy_node_t *pPolicy_node = NULL;
	healthpolicy_info_t *policy = NULL;
	int key;

	policy = find_healthpolicy_node_by_name((char *)policyName.c_str());
	if(NULL == policy) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:can not find policy node<%s>!!!\n",policyName.c_str());
		return RetCode::FAIL;
	}
	
	pPolicy_node = (pPolicy_node_t *)malloc(sizeof(pPolicy_node_t));
	if(NULL == pPolicy_node) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:malloc pPolicy_node failed!!!\n");
		return RetCode::FAIL;
	}
	memset(pPolicy_node,0,sizeof(pPolicy_node_t));
	
	pPolicy_node->pPolicy = policy;
	gettimeofday(&pPolicy_node->t_insert,NULL);
	pPolicy_node->t_insert.tv_sec += pPolicy_node->pPolicy->freq;


	memset(&ng_node,0,sizeof(nginxgroup_info_t));
	strcpy(ng_node.name,groupName.c_str());

	key = hs_nginx_group.hash_key((void *)ng_node.name,hs_nginx_group.num);

	head = &hs_nginx_group.tab[key].head;
	head_node = &hs_nginx_group.tab[key];
	
	pthread_mutex_lock(&head_node->lock);
	
	list_for_each(cur, head) {
		ng = (nginxgroup_info_t *)cur;
		if(!strcmp(ng->name,ng_node.name)) {
			break;
		}
	}
	
	pthread_mutex_unlock(&head_node->lock);

	if(cur != head) {
		list_add(&ng->pPolicy_head,&pPolicy_node->node);	
		cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:attach a policy=%s to nginxgroup=%s!!!\n",policyName.c_str(),groupName.c_str());		
	} else {
		cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:add a new nginxgroup=%s,policy=%s\n",groupName.c_str(),policyName.c_str());
		nginx_node = (nginxgroup_info_t *)malloc(sizeof(nginxgroup_info_t));
		if(NULL == nginx_node) {
			cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:malloc nginx_node failed!!!\n");
			free(pPolicy_node);
			return RetCode::FAIL;
		}		
		memset(nginx_node,0,sizeof(nginxgroup_info_t));

		strcpy(nginx_node->name,groupName.c_str());
		list_head_init(&nginx_node->srv_head);
		list_head_init(&nginx_node->pPolicy_head);

		list_add(&nginx_node->pPolicy_head,&pPolicy_node->node);
		hs_nginx_group.hash_add(&hs_nginx_group,nginx_node->name,&nginx_node->node);
	}
	
	cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:success!!!groupName = %s,policyName=%s\n",groupName.c_str(),policyName.c_str());
	//cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:success!!!\n");
	return RetCode::OK;

}
/*
RetCode::type DialHandler::modNginxGroup(const std::string& groupName, const std::string& policyName, const bool dialing)
{
	cfg_debug_printf(LOG_LEVEL_BASIC,"modNginxGroup:start!!!groupName = %s,policyName=%s,dialing=%d\n",groupName.c_str(),policyName.c_str(),dialing);

	nginxgroup_info_t ng_node;
	int key;
	DIAL_LIST_NODE *cur = NULL;
	DIAL_LIST_NODE *head = NULL;
	DIAL_LIST_HEAD *head_node = NULL;
	nginxgroup_info_t *ng = NULL;
	RetCode::type ret = RetCode::OK;
	
	memset(&ng_node,0,sizeof(nginxgroup_info_t));

	strcpy(ng_node.name,groupName.c_str());
	
	ng_node.pPolicy = find_healthpolicy_node_by_name((char *)policyName.c_str());
	if(NULL == ng_node.pPolicy) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"modNginxGroup:find_healthpolicy_node_by_name failed,no policy node<%s>!!!\n",policyName.c_str());
		//free(hg_node);
		return RetCode::FAIL;
	}

	key = hs_nginx_group.hash_key((void *)ng_node.name,hs_nginx_group.num);

	head = &hs_nginx_group.tab[key].head;
	head_node = &hs_nginx_group.tab[key];
	
	pthread_mutex_lock(&head_node->lock);
	
	list_for_each(cur, head) {
		ng = (nginxgroup_info_t *)cur;
		if(!strcmp(ng->name,ng_node.name)) {
			break;
		}
	}

	if(cur != head) {
		ng->pPolicy = ng_node.pPolicy;
		ng->enable = dialing;
		//cfg_debug_printf(LOG_LEVEL_BASIC,"modHealthGroup:success!!!\n");		
	} else {
		cfg_debug_printf(LOG_LEVEL_BASIC,"modNginxGroup:can not find the target node!!!name=%s\n",ng_node.name);
		ret = RetCode::FAIL;
	}
	
	pthread_mutex_unlock(&head_node->lock);

	return ret;

}*/

RetCode::type DialHandler::delNginxGroup(const std::string& groupName, const std::string& policyName) 
{
	cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxGroup:start!!!,name=%s,policyName=%s\n",groupName.c_str(),policyName.c_str());
	nginxgroup_info_t ng_node;
	int key;
	DIAL_LIST_NODE *cur = NULL;
	DIAL_LIST_NODE *node = NULL;
	DIAL_LIST_NODE *head = NULL;
	DIAL_LIST_HEAD *head_node = NULL;
	nginxgroup_info_t *ng = NULL;
	pPolicy_node_t *pPolicy_node = NULL;
	RetCode::type ret = RetCode::OK;
	
	memset(&ng_node,0,sizeof(nginxgroup_info_t));

	strcpy(ng_node.name,groupName.c_str());
	

	key = hs_nginx_group.hash_key((void *)ng_node.name,hs_nginx_group.num);
	node = hs_nginx_group.hash_search(&hs_nginx_group,(char *)ng_node.name);
	if(NULL == node) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxGroup:failed,can not find nginx groupnode=%s!!!\n",groupName.c_str());
		return RetCode::FAIL;
	}

	head_node = &hs_nginx_group.tab[key];
	ng = (nginxgroup_info_t *)node;
	head = &ng->pPolicy_head.head;

	pthread_mutex_lock(&ng->pPolicy_head.lock);

	list_for_each(cur,head) {
		pPolicy_node = (pPolicy_node_t *)cur;
		if(!strcmp(pPolicy_node->pPolicy->policyname,policyName.c_str()))
			break;
	}

	pthread_mutex_unlock(&ng->pPolicy_head.lock);

	if(cur != head) {
		list_del(&ng->pPolicy_head,&pPolicy_node->node);
		free(pPolicy_node);
		if(ng->pPolicy_head.num < 1){
			list_del(head_node,&ng->node);
			free(ng);
		}
	}else{
		cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxGroup:can not find target policynode=%s from nginxgroup=%s!!!\n",policyName.c_str(),groupName.c_str());
	}
	
	//cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxGroup:success!!!\n");
	return ret;

}

RetCode::type DialHandler::addNginxServer(const std::string& groupName, const DialNginxServer& server) 
{
	//cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxServer:start!!!\n");

	nginxgroup_info_t ng_node;
	DIAL_LIST_NODE *cur = NULL;
	DIAL_LIST_NODE *head = NULL;
	DIAL_LIST_HEAD *head_node = NULL;
	nginxgroup_info_t *ng = NULL;
	
	nginx_srv_t *srv_node = (nginx_srv_t *)malloc(sizeof(nginx_srv_t));
	if(NULL == srv_node) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxServer:malloc failed!!!\n");
		return RetCode::FAIL;
	}

	memset(srv_node,0,sizeof(nginx_srv_t));

	srv_node->priority = server.priority;
	strcpy(srv_node->url,server.localURL.c_str());

	cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxServer:groupName=%s,url=%s,priority=%d\n",groupName.c_str(),srv_node->url,srv_node->priority);
	
	memset(&ng_node,0,sizeof(nginxgroup_info_t));

	strcpy(ng_node.name,groupName.c_str());

	cur = hs_nginx_group.hash_search(&hs_nginx_group,(char *)ng_node.name);
	if(NULL == cur) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxServer:failed,can not find nginx group node!!!,name=%s,url=%s,priority=%d\n",ng_node.name,srv_node->url,srv_node->priority);
		free(srv_node);
		return RetCode::FAIL;
	}

	
	ng = (nginxgroup_info_t *)cur;
	
	 head_node = &ng->srv_head;

	list_add(head_node,&srv_node->node);

	//cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxServer:success!!!\n");
	return RetCode::OK;

}

RetCode::type DialHandler::modNginxServer(const std::string& groupName, const DialNginxServer& server) 
{
		//debug_printf(LOG_LEVEL_BASIC,"modNginxServer:start!!!\n");
	nginxgroup_info_t ng_node;
	DIAL_LIST_NODE *cur = NULL;
	DIAL_LIST_NODE *head = NULL;
	DIAL_LIST_HEAD *head_node = NULL;
	nginxgroup_info_t *ng = NULL;
	nginx_srv_t *psrv = NULL;
	RetCode::type ret = RetCode::OK;
	
	
	memset(&ng_node,0,sizeof(nginxgroup_info_t));

	strcpy(ng_node.name,groupName.c_str());

	cfg_debug_printf(LOG_LEVEL_BASIC,"modNginxServer:groupName=%s,priority=%d,url=%s\n",groupName.c_str(),server.priority,server.localURL.c_str());


	cur = hs_nginx_group.hash_search(&hs_nginx_group,(char *)ng_node.name);
	if(NULL == cur) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"modNginxServer:failed,can not find nginx group node!!!\n");
		return RetCode::FAIL;
	}

	ng = (nginxgroup_info_t *)cur;
	
	 head_node = &ng->srv_head;
	 head = &head_node->head;

	pthread_mutex_lock(&head_node->lock);
	
	 list_for_each(cur, head) {
		psrv = (nginx_srv_t *)cur;
		if(!strcmp(psrv->url,server.localURL.c_str()))
			break;
	 }
	if(cur != head) {
		strcpy(psrv->url,server.localURL.c_str());
		psrv->priority = server.priority;
		//cfg_debug_printf(LOG_LEVEL_BASIC,"modNginxServer:success!!!\n");
	} else {
		cfg_debug_printf(LOG_LEVEL_BASIC,"modNginxServer:failed,can not find target node.groupname=%s,url=%s,priority=%d!!!\n",groupName.c_str(),server.localURL.c_str(),server.priority);
		ret = RetCode::FAIL;
	}
	 
	 pthread_mutex_unlock(&head_node->lock);
	 
	return ret;

}

RetCode::type DialHandler::delNginxServer(const std::string& groupName, const DialNginxServer& server) 
{
		//cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxServer:start!!!\n");
	nginxgroup_info_t ng_node;
	DIAL_LIST_NODE *cur = NULL;
	DIAL_LIST_NODE *head = NULL;
	DIAL_LIST_HEAD *head_node = NULL;
	nginxgroup_info_t *ng = NULL;
	nginx_srv_t *psrv = NULL;
	RetCode::type ret = RetCode::OK;
	
	
	memset(&ng_node,0,sizeof(nginxgroup_info_t));

	strcpy(ng_node.name,groupName.c_str());

	cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxServer:groupName=%s,priority=%d,url=%s\n",groupName.c_str(),server.priority,server.localURL.c_str());


	cur = hs_nginx_group.hash_search(&hs_nginx_group,(char *)ng_node.name);
	if(NULL == cur) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxServer:failed,can not find nginx group node!!!\n");
		return RetCode::FAIL;
	}

	ng = (nginxgroup_info_t *)cur;
	
	 head_node = &ng->srv_head;
	 head = &head_node->head;

	pthread_mutex_lock(&head_node->lock);
	
	 list_for_each(cur, head) {
		psrv = (nginx_srv_t *)cur;
		if(!strcmp(psrv->url,server.localURL.c_str()))
			break;
	 }
	if(cur != head) {
		cur->next->prev = cur->prev;
		cur->prev->next = cur->next;
		head_node->num--;
		free(psrv);
		//cfg_debug_printf(LOG_LEVEL_BASIC,"modNginxServer:success!!!\n");
	} else {
		cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxServer:failed,can not find target node.groupname=%s,url=%s,priority=%d!!!\n",groupName.c_str(),server.localURL.c_str(),server.priority);
		ret = RetCode::FAIL;
	}
	 
	 pthread_mutex_unlock(&head_node->lock);
	 
	return ret;

}

/*
void DialHandler::heartBeat(HeartBeatState& _return) {

	cfg_debug_printf(LOG_LEVEL_BASIC,"heartBeat:receive a heat beat!!\n");

	if(registered_flag)
		_return.__set_mState(ModuleState::REGISTERED);
	else
		_return.__set_mState(ModuleState::STARTUP);
  }
*/

int 
create_client_udp_fd()
{
	int rtn = 0;
	int fd;
	int flag = 0;
	int fdbuflen;
	struct sockaddr_in cliaddr;
	struct timeval timeout;
	
	fd = socket(AF_INET,SOCK_DGRAM,0);
	if(fd < 0) {

		debug_printf(LOG_LEVEL_ERROR,"create_client_udp_fd failed\n");
		return ERROR;
	}

	timeout.tv_sec=0;
	timeout.tv_usec=(g_cfg.srv_cfg.timeout + 1)*1000;
	rtn = setsockopt(fd,SOL_SOCKET,SO_RCVTIMEO,(char *)&timeout,sizeof(struct timeval));
	if(rtn < 0){
                 debug_printf(LOG_LEVEL_ERROR,"create_client_udp_fd:setsockopt SO_RCVTIMEO failed \n");
                 return ERROR;
         }
	
	return fd;
}



RetCode::type send_update_health_status(const HealthGroupInfo& health, const std::vector<DialRecordStatus> & statusList,const std::string& policyName)
{
	RetCode::type rtn = RetCode::OK;
	pthread_t td_connecting;

	pthread_mutex_lock(&client_lock);
	
	if(!client_connecting_flag){//判断是否连接正常
		pthread_mutex_unlock(&client_lock);
		return RetCode::FAIL;
	}
	
	try{
		AgentClient client(protocol_client);
		//AgentClient client(tprotocol);

	  	rtn = client.updateHealthStatus(health,statusList,policyName);
	}catch(std::exception &e) {
		client_connecting_flag = false;
		transport_client->close(); 
		if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) {
			debug_printf(LOG_LEVEL_ERROR,"send_update_health_status:pthread_create failed!rtn = %d\n",rtn);
		}	
		debug_printf(LOG_LEVEL_ERROR,"send_update_health_status:catch an exception!--->%s\n",e.what());

	}
	
	pthread_mutex_unlock(&client_lock);
  
    	return rtn;
 
}

RetCode::type send_update_server_status(const DialServerStatus& status, const DialServerType::type typ)
{
	RetCode::type rtn = RetCode::OK;
	pthread_t td_connecting;
	
	pthread_mutex_lock(&client_lock);
	
	if(!client_connecting_flag){//判断是否连接正常
		pthread_mutex_unlock(&client_lock);
		return RetCode::FAIL;
	}
	
	try{
		AgentClient client(protocol_client);
		//AgentClient client(tprotocol);

	  	rtn = client.updateServerStatus(status,typ);
	}catch(std::exception &e) {
		client_connecting_flag = false;
		transport_client->close(); 
		if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) {
			debug_printf(LOG_LEVEL_ERROR,"send_update_server_status:pthread_create failed!rtn = %d\n",rtn);
		}	
		debug_printf(LOG_LEVEL_ERROR,"send_update_server_status:catch an exception!--->%s\n",e.what());

	}
	
	pthread_mutex_unlock(&client_lock);
  
    return rtn;
}


RetCode::type send_update_nginx_status(const std::string& groupName, const std::vector<DialNginxStatus> & statusList,const std::string& policyName)
{
	RetCode::type rtn = RetCode::OK;
	pthread_t td_connecting;
	
	pthread_mutex_lock(&client_lock);
	
	if(!client_connecting_flag){//判断是否连接正常
		pthread_mutex_unlock(&client_lock);
		return RetCode::FAIL;
	}
	
	try{
		AgentClient client(protocol_client);
		//AgentClient client(tprotocol);

	  	rtn = client.updateNginxStatus(groupName,statusList,policyName);
	}catch(std::exception &e) {
		client_connecting_flag = false;
		transport_client->close(); 
		if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) {
			debug_printf(LOG_LEVEL_ERROR,"send_update_nginx_status:pthread_create failed!rtn = %d\n",rtn);
		}	
		debug_printf(LOG_LEVEL_ERROR,"send_update_nginx_status:catch an exception!--->%s\n",e.what());

	}
	
	pthread_mutex_unlock(&client_lock);
  
    return rtn;
}


int
handle_dial_by_policy(healthgroup_info_t *hg,char *ip)
{
	int ret = 0;


	
	switch(hg->pPolicy->method) {
		case DIAL_TCPPORT:
			ret = handle_tcp_and_port_dialing(ip,hg->pPolicy->port);
			break;
		case DIAL_IMCP:
			ret = handle_icmp_dialing(ip);
			break;
		case DIAL_HTTPGET:
			ret = handle_httpget_dialing(ip,hg->pPolicy->port,(char *)"/",hg->name);
			break;
		case DIAL_DATABASE:
			ret = handle_db_dialing(ip,hg->pPolicy->dial_option.dest_url,hg->pPolicy->dial_option.test_method);
			break;	
		case DIAL_EXTHTTPGET:
			ret = handle_exthttpget_dialing(ip,hg->name,&hg->pPolicy->dial_option);
			break;
		default:
			ret = ERROR;
			debug_printf(LOG_LEVEL_ERROR,"handle_dial_by_policy:error dial method type=%d",hg->pPolicy->method);
			break;
	}


	return ret;		
}

int 
get_parameters_from_url(char *src,char *resource,char *ip,int *port,bool *https_flag)
{
	char *pstart = NULL;
	char pport[10] = {0};
	int i = 0;
	
	if(NULL == src) {
		debug_printf(LOG_LEVEL_ERROR,"get_parameters_from_url:invalid parameter,src is NULL\n");	
		return ERROR;
	}
	
	pstart = strstr(src,"http://");
	if(NULL == pstart) {
		pstart = strstr(src,"https://");
		if(NULL == pstart) {
			debug_printf(LOG_LEVEL_ERROR,"get_parameters_from_url:invalid parameter,src format error\n");
			return ERROR;
		} else {
			pstart += strlen("https://");
			*https_flag = true;
		}
		
	}else {
		pstart += strlen("http://");
		*https_flag = false;
	}


	//提取ip
	while(*pstart != '\0') {
		if(':' == *pstart || '/' == *pstart) {
			//pstart++;
			break;
		}else {
			*ip++ = *pstart++;
		}
	}

	if('\0' == *pstart || '/' == *pstart) {
		if(false == *https_flag)
			*port = 80;
		else
			*port = 443;
		
		if('\0' == *pstart)
			strcpy(resource,"/");
		else
			strcpy(resource,pstart);
		
		return NO_ERROR;
	}

	pstart++;
	//提取port
	while(*pstart != '\0') {
		if('/' == *pstart)
			break;
		else
			pport[i++] = *pstart++;
	}	
	
	if('\0' == *pstart) {
		*port = atoi(pport);
		strcpy(resource,"/");
	} else {
		*port = atoi(pport);
		strcpy(resource,pstart);
	}

	return NO_ERROR;
}


//handle_nginxgroup_dial(nginxgroup_info_t *ng,char *ip,char *resource,int port,bool https_flag)
int
handle_nginxgroup_dial(nginxgroup_info_t *ng,char *ip,int port)
{
	int ret = 0;

	
	switch(ng->pPolicy->method) {
		case DIAL_TCPPORT:
			ret = handle_tcp_and_port_dialing(ip,ng->pPolicy->port);
			break;
		case DIAL_IMCP:
			ret = handle_icmp_dialing(ip);
			break;
		case DIAL_HTTPGET:
//			ret = handle_httpget_dialing(ip,ng->pPolicy->port,(char *)"/",ng->name);
			ret = handle_httpget_dialing(ip,port,(char *)"/",ng->name);
			break;
		case DIAL_DATABASE:
			ret = handle_db_dialing(ip,ng->pPolicy->dial_option.dest_url,ng->pPolicy->dial_option.test_method);
			break;	
		case DIAL_EXTHTTPGET:
			ret = handle_exthttpget_dialing(ip,ng->name,&ng->pPolicy->dial_option);
			break;
		default:
			ret = ERROR;
			debug_printf(LOG_LEVEL_ERROR,"handle_nginxgroup_dial:error dial method type=%d",ng->pPolicy->method);
			break;
	}

	/*if(https_flag)
		ret = handle_httpsget_dialing(ip,port,resource,ip);	
	else
		ret = handle_httpget_dialing(ip,port,resource,ip);*/

	return ret;		
}



void
do_a_dial_healthgroup(healthgroup_info_t *hg)
{
	int ret = NO_ERROR;
	DIAL_LIST_NODE *cur = NULL;
	DIAL_LIST_NODE *head = &hg->precord_head->head;
	DIAL_LIST_HEAD *phead = hg->precord_head;
	record_info_t *rec = NULL;
	unsigned int i = 0;
	unsigned int j = 0;
	unsigned int success;
	HealthGroupInfo healthgroup;
	std::string policyName;

	pthread_mutex_lock(&phead->lock);
	
	std::vector<DialRecordStatus> statusList(phead->num);
	debug_printf(LOG_LEVEL_DEBUG,"1111111111\n");
	list_for_each(cur, head) {
		rec = (record_info_t *)cur;
		//debug_printf("do_a_dial_healthgroup:j=%d\n",j);
		success = 0;
		statusList[j].rid.assign(rec->rid);
		//开始拨测times 次
		for(i = 0;i < hg->pPolicy->times;i++) {
			ret = handle_dial_by_policy(hg,rec->ip.addr);
			if(NO_ERROR == ret)
				success++;
			usleep(50);
		}
		debug_printf(LOG_LEVEL_DEBUG,"do_a_dial_healthgroup:success=%d,dial_times=%d,pass_line =%d,dn=%s,ip=%s\n",
									success,hg->pPolicy->times, hg->pPolicy->passed,hg->name,rec->ip.addr);
		//小于通过标准，拨测失败
		if(success < hg->pPolicy->passed) {
			statusList[j].status = DialStatus::FAIL;
		}else {
			statusList[j].status = DialStatus::OK;
		}
		j++;
	}
	
	if(j > 0) {
		healthgroup.viewName.assign(hg->viewname);
		healthgroup.zoneName.assign(hg->zonename);
		healthgroup.name.assign(hg->name);
		policyName.assign(hg->pPolicy->policyname);

		//上报拨测结果
		send_update_health_status(healthgroup,statusList,policyName);
	}
	debug_printf(LOG_LEVEL_DEBUG,"22222222222\n");
	pthread_mutex_unlock(&phead->lock);
	
	//return ret;
}

int 
generate_dns_package(char *snd_msg,
						char *domain,
						int id)
{
	int msglen = 0;
	
	msglen = dns_fill_query((struct dnshdr_s *)snd_msg,domain,id, __cpu_to_be16(NS_FLAG_RD), __cpu_to_be16(NS_CLASS_IN),__cpu_to_be16(NS_TYPE_A));
	
	return msglen;
}

int
do_dns_dial(char *msg,
			int msg_len,
			struct sockaddr_in *servaddr,
			int fd)
{
	int rtn;
	int anslen;
	union {
		HEADER hdr;
		u_char buf[NS_PACKETSZ];
	} answer;
	struct timeval t_start;
	struct timeval t_end;

	rtn = sendto(fd,msg,msg_len,0,(struct sockaddr *)servaddr, sizeof(struct sockaddr_in));
	if(rtn < 0) {
		debug_printf(LOG_LEVEL_ERROR,"do_dns_dial:sendto failed,rtn = %d\n",rtn);
		return g_cfg.srv_cfg.timeout;
	}

	gettimeofday(&t_start,NULL);

	anslen = recvfrom(fd,&answer,sizeof(answer),0,NULL,NULL);
	if(anslen < 0) {
		debug_printf(LOG_LEVEL_ERROR,"do_dns_dial:recvfrom failed,fd=%d,anslen = %d\n",fd,anslen);
	}
	
	gettimeofday(&t_end,NULL);

	return ((t_end.tv_sec * 1000*1000 + t_end.tv_usec) - (t_start.tv_sec * 1000*1000 + t_start.tv_usec));
	//return (t_end.tv_usec - t_start.tv_usec);

}

int
server_dial_by_httpget(dial_srv_node_t *srv)
{
	int i;
	int rtn = 0;
	DialServerStatus server_status;
	RetCode::type rslt = RetCode::OK;

	for(i = 0;i < g_cfg.srv_cfg.count;i++) {	
		rtn = handle_httpget_dialing(srv->ip.addr,HTTPGET_PORT,(char *)"/",srv->ip.addr);
		if(NO_ERROR != rtn)
			break;			
	}
	
	server_status.ip.addr.assign(srv->ip.addr);
	server_status.ip.version = srv->ip.version;
	
	
	if(rtn == NO_ERROR && i < g_cfg.srv_cfg.count) 
		server_status.status = DialStatus::OK;
	else
		server_status.status = DialStatus::FAIL;

	rslt = send_update_server_status(server_status,srv->srv_tpye);
	if(RetCode::OK == rslt)
		return NO_ERROR;
	else {
		//debug_printf(LOG_LEVEL_ERROR,"server_dial_by_httpget:dial failed,ip=%s\n",srv->ip.addr);
		return ERROR;
	}

}

int
do_a_dial_server(dial_srv_node_t *srv)
{
	int fd;
	int i;
	int rtn;
	char msg[512] = {0};
	struct sockaddr_in servaddr;
	int msg_len = 0;
	//static int id = 1;
	int success = 0;
	int timeout = 0;
	int health_value = 0;
	DialServerStatus server_status;
	RetCode::type rslt = RetCode::OK;

	if(DialServerType::REDIRECT == srv->srv_tpye)
		return server_dial_by_httpget(srv);
	

	fd = create_client_udp_fd();
	if(ERROR == fd) {
		return ERROR;
	}

	//initialize server address
	memset(&servaddr, 0, sizeof(servaddr));	
	servaddr.sin_family = AF_INET;	
	servaddr.sin_port = htons(53);	
	inet_pton(AF_INET, srv->ip.addr, &servaddr.sin_addr);

	msg_len = generate_dns_package(msg,g_cfg.srv_cfg.dname,(pthread_self() + 1)%0xffff);

	for(i = 0;i < g_cfg.srv_cfg.count;i++) {
		
		 rtn = do_dns_dial(msg,msg_len,&servaddr,fd);
		 if(rtn < g_cfg.srv_cfg.timeout*1000) {
		 	success++;
		 	timeout += rtn;
		 }
	}

	close(fd);
	
	if(success >0)
		health_value = (timeout/success*g_cfg.srv_cfg.delay_weight) + (g_cfg.srv_cfg.count - success)*g_cfg.srv_cfg.lost_weight;

	debug_printf(LOG_LEVEL_DEBUG,"do_a_dial_server:ip=%s,type=%d,health_value=%d,dial_success_times=%d,timeout=%d\n",srv->ip.addr,srv->srv_tpye,health_value,success,timeout);

	server_status.ip.addr.assign(srv->ip.addr);
	server_status.ip.version = srv->ip.version;
	
	
	if(success >0 && health_value < g_cfg.srv_cfg.health) 
		server_status.status = DialStatus::OK;
	else
		server_status.status = DialStatus::FAIL;
		
	rslt = send_update_server_status(server_status,srv->srv_tpye);
	if(RetCode::OK == rslt)
		return NO_ERROR;
	else {
		//debug_printf("do_a_dial_server:send_update_server_status failed\n");
		return ERROR;
	}
}

void
do_a_dial_nginxgroup(nginxgroup_info_t *ng)
{
	int ret = NO_ERROR;
	DIAL_LIST_NODE *cur = NULL;
	DIAL_LIST_NODE *head = &ng->psrv_head->head;
	DIAL_LIST_HEAD *phead = ng->psrv_head;
	nginx_srv_t *srv = NULL;
	unsigned int i = 0;
	unsigned int j = 0;
	unsigned int success;
	std::string  groupName;
	int port = 0;
	char resource[1024];
	char ip[26];
	bool httpsflag;
	std::string policyName;

	

	pthread_mutex_lock(&phead->lock);
	
	std::vector<DialNginxStatus> statusList(phead->num);
	debug_printf(LOG_LEVEL_DEBUG,"do_a_dial_nginxgroup:1111111111\n");
	list_for_each(cur, head) {
		srv = (nginx_srv_t *)cur;
		//debug_printf("do_a_dial_healthgroup:j=%d\n",j);
		success = 0;
		statusList[j].server.localURL.assign(srv->url);
		statusList[j].server.priority = srv->priority;

		port = 0;
		httpsflag = false;
		memset(resource,0,sizeof(resource));
		memset(ip,0,sizeof(ip));

		//仅http方式拨测
		/*if(DIAL_HTTPGET != ng->pPolicy->method) {
			debug_printf(LOG_LEVEL_DEBUG,"do_a_dial_nginxgroup:dial method invalid,method=%d\n",ng->pPolicy->method);
			goto NEXT_STEP;
		}*/
			
		//提取拨测参数
		ret = get_parameters_from_url(srv->url,resource,ip,&port,&httpsflag);
		if(ret < 0) {
			goto NEXT_STEP;
		}
		
		//开始拨测times 次
		for(i = 0;i < ng->pPolicy->times;i++) {
//			ret = handle_nginxgroup_dial(ng,ip);
			ret = handle_nginxgroup_dial(ng,ip,port);
			if(NO_ERROR == ret)
				success++;
			usleep(50);
		}

NEXT_STEP:
		debug_printf(LOG_LEVEL_DEBUG,"do_a_dial_nginxgroup:success=%d,dial_times=%d,pass_line=%d,url%s\n",
									success,ng->pPolicy->times, ng->pPolicy->passed,srv->url);
		//小于通过标准，拨测失败
		if(success < ng->pPolicy->passed) {
			statusList[j].status = DialStatus::FAIL;
		}else {
			statusList[j].status = DialStatus::OK;
		}
		j++;
	}
	
	if(j > 0) {
		groupName.assign(ng->name);
		policyName.assign(ng->pPolicy->policyname);

		//上报拨测结果
		send_update_nginx_status(groupName,statusList,policyName);
	}
	debug_printf(LOG_LEVEL_DEBUG,"do_a_dial_nginxgroup:22222222222\n");
	pthread_mutex_unlock(&phead->lock);
	
	//return ret;
}



int 
dial_config_check(dial_cfg_t *config)
{
	config->srv_cfg.allowed[0] = true;
	config->srv_cfg.allowed[1] = true;
	config->srv_cfg.allowed[2] = true;

	if(config->srv_cfg.count <= 0)
		config->srv_cfg.count = 1;
	if(config->srv_cfg.health  <= 0)
		config->srv_cfg.count = 5000;
	if(config->srv_cfg.delay_weight  <= 0)
		config->srv_cfg.delay_weight = 10;
	if(config->srv_cfg.lost_weight  <= 0)
		config->srv_cfg.lost_weight = 10;
	if(config->srv_cfg.timeout<= 0)
		config->srv_cfg.timeout = 50;
	if(config->srv_cfg.interval<= 0)
		config->srv_cfg.interval = 5;

	if(strlen(config->srv_cfg.dname) <= 0) {
		memset(config->srv_cfg.dname,0,sizeof(config->srv_cfg.dname));
		strcpy(config->srv_cfg.dname,"www.sina.com");
	}
	
	if(strlen(config->log_path) <= 0) {
		strcpy(config->log_path,"/var/log/");
	}
	
	if(config->log_level <= 0) {
		config->log_level = 1;
	}
	
	cfg_debug_printf(LOG_LEVEL_BASIC,"dial_config_check:dial_config===>health=%d,delay_weight=%d,lost_weight=%d,count=%d,timeout=%d,interval=%d,dname=%s\n",
						config->srv_cfg.health,config->srv_cfg.delay_weight,config->srv_cfg.lost_weight,config->srv_cfg.count,config->srv_cfg.timeout,config->srv_cfg.interval,config->srv_cfg.dname);

}

int 
load_sys_config(dial_cfg_t *cfg,
					char *filename)
{
	FILE *fp = NULL;
	char tmp[500] = {0};
	
	fp = fopen(filename,"r");
	if(NULL == fp) {
		cfg_debug_printf(LOG_LEVEL_ERROR,"load_sys_config:open the file %s failed\n",filename);
		return ERROR;
	}


	while(!feof(fp)) {
	
		memset(tmp,0,sizeof(tmp));
		fgets(tmp,sizeof(tmp),fp);
		
		//debug_printf("get tmp is %s",tmp);		
		if(NULL != strstr(tmp,"#dial process port")) {

			fscanf(fp,"port=%d",&cfg->dial_port);
			
		}else if(NULL != strstr(tmp,"#Agent info")) {
			fscanf(fp,"port=%d",&cfg->agent_port);
			fgets(tmp,sizeof(tmp),fp);
			fscanf(fp,"ip=%s",cfg->agent_ip);
		}else if(NULL != strstr(tmp,"#server dial config")) {
			fscanf(fp,"health=%d",&cfg->srv_cfg.health);
			fgets(tmp,sizeof(tmp),fp);
			fscanf(fp,"delay_weight=%d",&cfg->srv_cfg.delay_weight);
			fgets(tmp,sizeof(tmp),fp);
			fscanf(fp,"lost_weight=%d",&cfg->srv_cfg.lost_weight);
			fgets(tmp,sizeof(tmp),fp);
			fscanf(fp,"count=%d",&cfg->srv_cfg.count);
			fgets(tmp,sizeof(tmp),fp);
			fscanf(fp,"timeout=%d",&cfg->srv_cfg.timeout);
			fgets(tmp,sizeof(tmp),fp);
			fscanf(fp,"interval=%d",&cfg->srv_cfg.interval);
			fgets(tmp,sizeof(tmp),fp);			
			fscanf(fp,"dname=%s",cfg->srv_cfg.dname);
		}else if(NULL != strstr(tmp,"#log config")) {
			fscanf(fp,"path=%s",cfg->log_path);		
			fgets(tmp,sizeof(tmp),fp);
			fscanf(fp,"level=%d",&cfg->log_level);
		}else if(NULL != strstr(tmp,"#certificate config")) {
			fscanf(fp,"path=%s",cfg->certificate_file);		
		}

	}
	fclose(fp);
	cfg_debug_printf(LOG_LEVEL_BASIC,"load_sys_config:agent_ip = %s,agent_port=%d,dial_server_port=%d\n",cfg->agent_ip,cfg->agent_port,cfg->dial_port);
	cfg_debug_printf(LOG_LEVEL_BASIC,"load_sys_config:dial_config===>health=%d,delay_weight=%d,lost_weight=%d,count=%d,timeout=%d,interval=%d,dname=%s,log_path=%s,log_level=%d,certificate_file=%s\n",
					cfg->srv_cfg.health,cfg->srv_cfg.delay_weight,cfg->srv_cfg.lost_weight,cfg->srv_cfg.count,cfg->srv_cfg.timeout,cfg->srv_cfg.interval,cfg->srv_cfg.dname,cfg->log_path,cfg->log_level,cfg->certificate_file);

	return NO_ERROR;
}

void
srv_dial_list_init()
{

	list_head_init(&list_dial_srv);
}

void
thrift_init(int port)
{
	//int port = 9092;
	shared_ptr<DialHandler> handler(new DialHandler());
	shared_ptr<TProcessor> processor(new DialProcessor(handler));
	shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
	shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
	shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

	TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
	
	server.serve();
}

void
thrift_client_init(char *ip,int port)
{
	boost::shared_ptr<TSocket> tsocket(new TSocket(ip, port));  
	boost::shared_ptr<TTransport> ttransport(new TBufferedTransport(tsocket));  
	boost::shared_ptr<TProtocol> tprotocol(new TBinaryProtocol(ttransport)); 


	transport_client = ttransport;
	protocol_client = tprotocol;
}


int
sys_init()
{
	int rtn;
	int agent_port = 0;
	char agent_ip[50] = {0};

	pthread_mutex_init(&g_log_lock,NULL);

	/*s_debug_switch = true;
	
	rtn = signal_init();
	if(rtn != NO_ERROR) {
		debug_printf(LOG_LEVEL_ERROR,"sys_init:switch_signal_init  failed!!\n");
		return ERROR;
	}

	rtn = sys_log_timer_init();
	if(rtn != NO_ERROR) {
		debug_printf(LOG_LEVEL_ERROR,"sys_init:sys_log_timer_init  failed!!\n");
		return ERROR;
	}*/
	//alarm(30);

	//load configure
	memset(&g_cfg,0,sizeof(dial_cfg_t));
	rtn = load_sys_config(&g_cfg,(char *)CONFIG_FILE);
	if(rtn != NO_ERROR) {
		cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:load_sys_config  failed!!\n");
		return ERROR;
	}

	dial_config_check(&g_cfg);

	//initializing socket info of agent
	thrift_client_init(g_cfg.agent_ip,g_cfg.agent_port);


	rtn = hash_init_healthpolicy(&hs_health_policy,HASH_POLICY_NUM);
	if(rtn != NO_ERROR) {
		cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:init hs_health_policy failed!!\n");
		return ERROR;
	}

	rtn = hash_init_healthgroup(&hs_health_group,HASH_GROUP_NUM);
	if(rtn != NO_ERROR) {
		cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:init hs_health_group failed!!\n");
		return ERROR;
	}

	rtn = hash_init_nginxgroup(&hs_nginx_group,HASH_NGINX_NUM);
	if(rtn != NO_ERROR) {
		debug_printf(LOG_LEVEL_ERROR,"sys_init:init hs_nginx_group failed!!\n");
		return ERROR;
	}
	srv_dial_list_init();
	
	//初始化队列
	queue_init(&queue_info);

	/*rtn = threadpool_init(&tp,THREAD_POOL_NUM);
	if(0 != rtn) {
		debug_printf("sys_init:threadpool_init  failed!!\n");
		return ERROR;
	}*/

	/*raw_fd = create_client_raw_socket();
	if(raw_fd < 0) {
		debug_printf("sys_init:create_client_raw_socket  failed!!raw_fd = %d\n",raw_fd);
		return ERROR;	
	}*/
	
	primary_flag = true;
	//可界面交互端口打开
	//ttransport->open(); 
	//AgentClient client(tprotocol);
  	//client.registerModule(ModuleType::DIALING);
  	if ((rtn = pthread_mutex_init(&client_lock,NULL)) != 0) {
		cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:pthread_mutex_init  failed!!\n");
		return ERROR;
	}

	init_openssl();

	return NO_ERROR;
}

inline void
add_task_to_queue_buffer(healthgroup_info_t *hg,healthpolicy_info_t  *policy)
{
	healthgroup_info_t *hg_node = (healthgroup_info_t *)malloc(sizeof(healthgroup_info_t));
	dial_node_t *task_node = (dial_node_t *)malloc(sizeof(dial_node_t));
	memset(hg_node,0,sizeof(healthgroup_info_t));
	memset(task_node,0,sizeof(dial_node_t));

	memcpy(hg_node,hg,sizeof(healthgroup_info_t));
	hg_node->node.next = NULL;
	hg_node->node.prev = NULL;
	hg_node->precord_head = &hg->record_head;
	hg_node->pPolicy = policy;

	task_node->type = HEALTHGROUP;
	task_node->dial_node.healthgroup = hg_node;

	queue_push(&queue_info, &task_node->node);
}

inline void
add_task_to_queue_buffer_2(dial_srv_node_t *node)
{
	dial_srv_node_t *srv_node = (dial_srv_node_t *)malloc(sizeof(dial_srv_node_t));
	dial_node_t *task_node = (dial_node_t *)malloc(sizeof(dial_node_t));
	memset(srv_node,0,sizeof(dial_srv_node_t));
	memset(task_node,0,sizeof(dial_node_t));

	memcpy(srv_node,node,sizeof(dial_srv_node_t));
	srv_node->node.next = NULL;
	srv_node->node.prev = NULL;

	task_node->type = SERVER;
	task_node->dial_node.srv = srv_node;

	queue_push(&queue_info, &task_node->node);
}

inline void
add_task_to_queue_buffer3(nginxgroup_info_t *hg,healthpolicy_info_t *policy)
{
	nginxgroup_info_t *ng_node = (nginxgroup_info_t *)malloc(sizeof(nginxgroup_info_t));
	dial_node_t *task_node = (dial_node_t *)malloc(sizeof(dial_node_t));
	memset(ng_node,0,sizeof(nginxgroup_info_t));
	memset(task_node,0,sizeof(dial_node_t));

	memcpy(ng_node,hg,sizeof(nginxgroup_info_t));
	ng_node->node.next = NULL;
	ng_node->node.prev = NULL;
	ng_node->psrv_head = &hg->srv_head;
	ng_node->pPolicy = policy;

	task_node->type = NGINX;
	task_node->dial_node.nginxgroup = ng_node;

	queue_push(&queue_info, &task_node->node);
}


void
queue_buffer_destroy(queue_info_t *info)
{
	DIAL_LIST_NODE *node = NULL;	
	healthgroup_info_t *hg = NULL;

	while(NULL != info->tail) {
		
		node = queue_pop(info);
		hg = (healthgroup_info_t *)node;
		if(NULL != node)
			free(hg);	
	}
}

void
dial_srv_list_destroy(DIAL_LIST_HEAD *list)
{
	DIAL_LIST_NODE *cur = NULL;	
	DIAL_LIST_NODE *tmp = NULL;	
	DIAL_LIST_NODE *head = &list->head;
	dial_srv_node_t *srv_node = NULL;
	
	list_for_each_safe(cur, tmp, head) {
		list_del(&list_dial_srv,cur);
		srv_node = (dial_srv_node_t *)cur;
		if(NULL != srv_node)
			free(srv_node);
	}
	
}

int
sys_free()
{
	threadpool_destroy(&tp);
	hash_destory_healthgroup(&hs_health_group);
	hash_destory_healthgroup(&hs_nginx_group);
	hash_destory_healthpolicy(&hs_health_policy);
	queue_buffer_destroy(&queue_info);	
	dial_srv_list_destroy(&list_dial_srv);
	
	//close(raw_fd)
	transport_client->close(); 
	
	return NO_ERROR;
}


#define TIME_CMPARE(a,b) (((a)->tv_sec * 1000*1000 + (a)->tv_usec) - ((b)->tv_sec * 1000*1000 + (b)->tv_usec)) 


void *
dial_monitor_thread(void *arg)
{
	int i;
	DIAL_LIST_NODE *cur = NULL;
	DIAL_LIST_NODE *head =NULL;
	DIAL_LIST_NODE *cur_p = NULL;
	DIAL_LIST_NODE *head_p =NULL;
	DIAL_LIST_HEAD *phead = NULL;
	pPolicy_node_t *policy = NULL;
	healthgroup_info_t *hg = NULL;
	struct timeval t_now;
	

	while(thread_exit_flag) {
		
		for(i = 0; i < hs_health_group.num; ++i) {
			if(1 != primary_flag)//非主机，不做拨测
				break;
			
			cur = NULL;
			head = &(hs_health_group.tab[i].head);
			phead = &(hs_health_group.tab[i]);

			pthread_mutex_lock(&phead->lock);
			list_for_each(cur,head) {
				hg = (healthgroup_info_t *)cur;
				//debug_printf(LOG_LEVEL_DEBUG,"start check a task!!!!!!\n");
				
				head_p = &hg->pPolicy_head.head;
				list_for_each(cur_p,head_p) {
					policy = (pPolicy_node_t *)cur_p;
					
					gettimeofday(&t_now,NULL);
					//if(TIME_CMPARE(&t_now,&hg->t_insert) > 0) {
					if(((t_now.tv_sec * 1000*1000 + t_now.tv_usec) - (policy->t_insert.tv_sec * 1000*1000 + policy->t_insert.tv_usec)) >= 0) {
						add_task_to_queue_buffer(hg,policy->pPolicy);
						
						debug_printf(LOG_LEVEL_ERROR,"dial_monitor_thread1:add a task!!!!!!\n");
						/*
						if(tp.threads_used < tp.act_threads_num) 
						{
							pthread_cond_signal(&tp.cond);
						}
						*/
						policy->t_insert = t_now;
						policy->t_insert.tv_sec += policy->pPolicy->freq;					
					}
				}
			}
			pthread_mutex_unlock(&phead->lock);
		}	
		//debug_printf("dial_monitor_thread_!\n");
		sleep(1);
	}

}

void *
dial_monitor_thread2(void *arg)
{
	int i;
	DIAL_LIST_NODE *cur = NULL;
	DIAL_LIST_NODE *head =NULL;
	DIAL_LIST_HEAD *phead = NULL;

	dial_srv_node_t *srv_node = NULL;
	struct timeval t_now;
	

	while(thread_exit_flag) {
		
			if(1 != primary_flag){//非主机，不做拨测
				sleep(1);
				continue;;
			}
			cur = NULL;
			head = &list_dial_srv.head;
			phead = &list_dial_srv;

			pthread_mutex_lock(&phead->lock);
			list_for_each(cur,head) {
				srv_node = (dial_srv_node_t *)cur;
				//debug_printf(LOG_LEVEL_DEBUG,"start check a task!!!!!!\n");
				if(true != g_cfg.srv_cfg.allowed[srv_node->srv_tpye])//server dial switch
					continue;
					
				gettimeofday(&t_now,NULL);	
				if(((t_now.tv_sec * 1000*1000 + t_now.tv_usec) - (srv_node->t_insert.tv_sec * 1000*1000 + srv_node->t_insert.tv_usec)) >= 0) {
					add_task_to_queue_buffer_2(srv_node);
					
					debug_printf(LOG_LEVEL_ERROR,"dial_monitor_thread2:add a task!!!!!!\n");
					/*
					if(tp.threads_used < tp.act_threads_num) 
					{
						pthread_cond_signal(&tp.cond);
					}
					*/
					srv_node->t_insert = t_now;
					srv_node->t_insert.tv_sec += g_cfg.srv_cfg.interval;					
				}				
			}
			pthread_mutex_unlock(&phead->lock);

		
		sleep(1);
	}

}

void *
dial_monitor_thread3(void *arg)
{
	int i;
	DIAL_LIST_NODE *cur = NULL;
	DIAL_LIST_NODE *head =NULL;
	DIAL_LIST_HEAD *phead = NULL;
	DIAL_LIST_NODE *cur_p = NULL;
	DIAL_LIST_NODE *head_p =NULL;
	pPolicy_node_t *policy = NULL;
	nginxgroup_info_t *ng = NULL;
	struct timeval t_now;
	

	while(thread_exit_flag) {
		
		for(i = 0; i < hs_nginx_group.num; ++i) {
			if(1 != primary_flag)//非主机，不做拨测
				break;
			
			cur = NULL;
			head = &(hs_nginx_group.tab[i].head);
			phead = &(hs_nginx_group.tab[i]);

			pthread_mutex_lock(&phead->lock);
			list_for_each(cur,head) {
				ng = (nginxgroup_info_t *)cur;

				//if(true != ng->enable)//nginx dial switch
					//continue;
				head_p = &ng->pPolicy_head.head;
				list_for_each(cur_p,head_p) {
					policy = (pPolicy_node_t *)cur_p;
					
					gettimeofday(&t_now,NULL);
					//if(TIME_CMPARE(&t_now,&hg->t_insert) > 0) {
					if(((t_now.tv_sec * 1000*1000 + t_now.tv_usec) - (policy->t_insert.tv_sec * 1000*1000 + policy->t_insert.tv_usec)) >= 0) {
						add_task_to_queue_buffer3(ng,policy->pPolicy);
						
						debug_printf(LOG_LEVEL_DEBUG,"dial_monitor_thread3:add a task!!!!!!\n");
						/*
						if(tp.threads_used < tp.act_threads_num) 
						{
							pthread_cond_signal(&tp.cond);
						}
						*/
						policy->t_insert = t_now;
						policy->t_insert.tv_sec += policy->pPolicy->freq;					
					}
				}
			}
			pthread_mutex_unlock(&phead->lock);
		}	
		//debug_printf("dial_monitor_thread3!\n");
		sleep(1);
	}

}


void *dial_monitor_queue_thread(void *arg)
{     
		while(thread_exit_flag) 
		{
				if(tp.threads_used < tp.act_threads_num && queue_info.cnt > 0) 
				{
						pthread_cond_signal(&tp.cond);
						debug_printf(LOG_LEVEL_BASIC,"queue have %d task,a signal to work thread!!\n",queue_info.cnt);
				}
				else
				{
						sleep(5);
						debug_printf(LOG_LEVEL_BASIC,"no task queue is empty!!\n");
				}     
		}
}



void *
start_register_thread(void *arg)
{
	debug_printf(LOG_LEVEL_BASIC,"start_register_thread:register start!\n");
	bool success_flag = true;
	
	while(1) {
		if(success_flag)
			usleep(50*1000);
		else
			sleep(2);
		
		//可界面交互端口打开
		try{
			RetCode::type ret;

			transport_client->open(); 
			AgentClient client(protocol_client);
			ret = client.registerModule(ModuleType::DIALING);
			if(ret != RetCode::OK) {
				debug_printf(LOG_LEVEL_ERROR,"start_register_thread:register failed,continue!!\n");
				continue;
			}
			
		}catch(std::exception &e) {
			success_flag = false;
			debug_printf(LOG_LEVEL_ERROR,"start_register_thread:catch an exception!-->%s\n",e.what());
			continue;
		}
	  	client_connecting_flag = true;
		registered_flag = true;
		break;
	}
	debug_printf(LOG_LEVEL_BASIC,"start_register_thread:register over!\n");
}

void *
client_reconnect_thread(void *arg)
{
	debug_printf(LOG_LEVEL_DEBUG,"client_reconnect_thread: start!\n");
	bool success_flag = true;


	//thrift_client_init(g_cfg.agent_ip,g_cfg.agent_port);
	while(1) {
		usleep(500*1000);
		
		try{
			
			transport_client->open(); 
			
		}catch(std::exception &e) {
			debug_printf(LOG_LEVEL_ERROR,"client_reconnect_thread:catch an exception!-->%s\n",e.what());
			continue;
		}
	  	client_connecting_flag = true;
		break;
	}
	debug_printf(LOG_LEVEL_DEBUG,"client_reconnect_thread: over!\n");
}

int
set_core_file()
{
	struct rlimit rlim_new,rlim;
	
	if (getrlimit(RLIMIT_CORE, &rlim)==0) {
  		rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;
  		if (setrlimit(RLIMIT_CORE, &rlim_new)!=0) {
   			rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;
    		(void) setrlimit(RLIMIT_CORE, &rlim_new);			
			cfg_debug_printf(LOG_LEVEL_ERROR,"set_core_file:setrlimit failed!!\n");
			return -1;
 		 }
	}else{
		cfg_debug_printf(LOG_LEVEL_ERROR,"set_core_file:getrlimit failed!!\n");
		return -1;
	}

	return 0;
}

void
log_debug_open(int sig)
{
	s_debug_switch = true;
}

void
log_debug_close(int sig)
{
	s_debug_switch = false;
}


void 
set_timer_handler(int sig)
{
	debug_printf(LOG_LEVEL_BASIC,"set_timer_handler:log closed!!\n");

	log_debug_close(sig);
}

int
signal_init()
{

	// 调试开关
	if(SIG_ERR == signal(SIGUSR1,log_debug_close)) {
		cfg_debug_printf(LOG_LEVEL_ERROR,"signal_init:can't catch SIGUSR1!!\n");
		return ERROR;
	}
	if(SIG_ERR == signal(SIGUSR2,log_debug_open)) {
		cfg_debug_printf(LOG_LEVEL_ERROR,"signal_init:can't catch SIGUSR2!!\n");
		return ERROR;
	}
	//定时器
	if(SIG_ERR == signal(SIGALRM,set_timer_handler)) {
		cfg_debug_printf(LOG_LEVEL_ERROR,"signal_init:can't catch SIGALRM!!\n");
		return ERROR;
	}
	return NO_ERROR;
}

int
sys_log_timer_init()
{	
	struct itimerval 		timer; 
	int ret = 0;

	memset(&timer, 0, sizeof(timer));

	
	// 设置超时时间为5分钟
	timer.it_value.tv_sec = 5*60;
	timer.it_value.tv_usec = 0;
	timer.it_interval = timer.it_value;
	
       // 设置计时器ITIMER_REAL
	ret = setitimer(ITIMER_REAL, &timer, NULL);
	if(ret < 0) {
		debug_printf(LOG_LEVEL_ERROR,"sys_log_timer_init:setitimer failed!!\n");
		return ERROR;
	}

	return NO_ERROR;	   
}

int main(int argc, char **argv) 
{
	int rtn = NO_ERROR;
	pthread_t td1,td2,td3,td4;
	pthread_t td_register;
	//int dial_server_port = 0;
	bool need_daemon = false;

	
	if(argc >= 2){
	        for(int i = 1; i < argc; i++){

	            if (strcmp("start", argv[i]) == 0) {
	                need_daemon = true;
	                continue;
	            } else if (strcmp("stop", argv[i]) == 0) {
	                daemon_stop();
	                exit(0);
	            } else if (strcmp("restart", argv[i]) == 0) {
	                daemon_stop();
	                need_daemon = true;
	                continue;
	            }else if(strcmp("-v", argv[i]) == 0){
					printf("%s",DIAL_VERSION);
					return -1;
				} else {
	           	  printf("unkown param:%s\n",argv[i]);
	                return -1;
	            }
	        }
	}else{
		printf("usage:dial start|stop|restart\n");
	       return -1;
	}

	rtn = sys_init();
	if(rtn != NO_ERROR) {
		printf("process start failed!\n");
		return ERROR;
	}


	if(need_daemon)
		daemon_start(1);

	s_debug_switch = true;
	thread_exit_flag = true;
	
	rtn = signal_init();
	if(rtn != NO_ERROR) {
		cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init: failed!!\n");
		return ERROR;
	}

	rtn = sys_log_timer_init();
	if(rtn != NO_ERROR) {
		cfg_debug_printf(LOG_LEVEL_ERROR,"sys_log_timer_init: failed!!\n");
		return ERROR;
	}

	set_core_file();

	rtn = threadpool_init(&tp,THREAD_POOL_NUM);
	if(0 != rtn) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"sys_init:threadpool_init  failed!!\n");
		return ERROR;
	}
	
	if ((rtn = pthread_create(&td1,NULL,dial_monitor_thread,NULL))!=0) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed!dial_monitor_thread,rtn = %d\n",rtn);
		return ERROR;
	}
	
	if ((rtn = pthread_create(&td2,NULL,dial_monitor_thread2,NULL))!=0) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed!dial_monitor_thread2,rtn = %d\n",rtn);
		return ERROR;
	}
	
	if ((rtn = pthread_create(&td3,NULL,dial_monitor_thread3,NULL))!=0) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed!dial_monitor_thread3,rtn = %d\n",rtn);
		return ERROR;
	}	
	
	if ((rtn = pthread_create(&td4,NULL,dial_monitor_queue_thread,NULL))!=0) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed!dial_monitor_queue_thread,rtn = %d\n",rtn);
		return ERROR;
	}	
	
	if ((rtn = pthread_create(&td_register,NULL,start_register_thread,NULL))!=0) {
		cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed!start_register_thread,rtn = %d\n",rtn);
		return ERROR;
	}			


	cfg_debug_printf(LOG_LEVEL_BASIC,"*****************dial module start ***********\n");

		
	thrift_init(g_cfg.dial_port);
	
	cfg_debug_printf(LOG_LEVEL_BASIC,"*****************dial module over,thrift died! ***********\n");

	thread_exit_flag = false;
	sleep(5);
	sys_free();
	pthread_join(td1,NULL);
	pthread_join(td2,NULL);
	pthread_join(td3,NULL);
	pthread_join(td_register,NULL);
	
	return NO_ERROR;
}

